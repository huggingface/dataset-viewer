# Contributing guide

The repository is structured as a monorepo, with Python applications in [services/](./services/) and Python libraries in [libs/](./libs/).

## Install

To start working on the project:

```bash
git clone git@github.com:huggingface/datasets-preview-backend.git
cd datasets-preview-backend
```

then install:

- [libs/libcache](./libs/libcache/INSTALL.md)
- [libs/libqueue](./libs/libcache/INSTALL.md)
- [libs/libutils](./libs/libutils/INSTALL.md)
- [services/api_service](./services/api_service/INSTALL.md)
- [services/job_runner](./services/job_runner/INSTALL.md)

If you use VSCode, it might be useful to use the ["monorepo" workspace](./.vscode/monorepo.code-workspace) (see a [blogpost](https://medium.com/rewrite-tech/visual-studio-code-tips-for-monorepo-development-with-multi-root-workspaces-and-extension-6b69420ecd12) for more explanations). It is a multi-root workspace, with one folder for each library and service (note that we hide them from the ROOT to avoid editing there). Each folder has its own Python interpreter, with access to the dependencies installed by Poetry. You might have to manually select the interpreter in every folder though on first access, then VSCode stores the information in its local storage.

## Quality

The CI checks the quality of the code through a [GitHub action](./.github/workflows/quality.yml). To manually format the code of a library or a service:

```bash
make style
```

To check the quality (which includes checking the style, but also security vulnerabilities):

```bash
make quality
```

## Tests

The CI checks the tests a [GitHub action](./.github/workflows/unit-tests.yml). To manually test a library or a service:

```bash
make test
```

## Poetry

### Hack: reference through the root

The structure is a monorepo, and the dependencies to the libraries are local (see the poetry doc on [`path` dependencies](https://python-poetry.org/docs/dependency-specification/#path-dependencies], note that we set `develop=true`). To have this work as expected, we have to use a little trick: to refer to all the libraries going down to the root, then going to the library directory. For example, to declare `libutils` as a dependency of `libcache`, even if they are in the same directory, we use `../../libs/libutils`:

```toml
libutils = { path = "../../libs/libutils", develop = true }
```

Otherwise, if we only used `../libutils`, the dependencies would break in the `poetry.lock` file of the services that depend on `libcache` for example. Possibly it's a bug in poetry.

### Lock

Poetry keeps the exact version of all the dependencies in `poetry.lock`. If you manually change `pyproject.toml`, you will have to call `poetry lock` (or `make lock`) to update `poetry.lock`. Beware: it might also upgrade the dependencies (use [`--no-update`](https://python-poetry.org/docs/cli/#options-9) if you want to avoid this).

If you update the dependencies of a library, you will have to run `poetry lock` (or `make lock`) in every library or service that depend on it. Beware, refreshing the lock on [services/job_runner](./services/job_runner) takes a lot of time.

In case you wonder, the `poetry.lock` files must be versioned.

## Versions

We don't change the version of the libraries and services in `pyproject.toml`, because they are local dependencies and access to the current files anyway. But before deploying to prod, we create a git tag that we increment accordingly to the change (major/minor/bugfix), for example:

```
git tag 0.20.2
git push --tags
```

Then we create a release at https://github.com/huggingface/datasets-preview-backend/releases/new, choosing a tag, then using the button "+ Auto-generate release notes".

## Pull requests

All the contributions should go through a pull request. The pull requests must be "squashed" (ie: one commit per pull request). Take care of the squash commit title and message, because it's what is included in the autogenerated release notes.
