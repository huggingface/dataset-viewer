# resources for the prod namespace are defined here: https://us-east-1.console.aws.amazon.com/eks/home?region=us-east-1#/clusters/hub-prod/nodegroups/datasets-server-20220513085103612000000001
# the nodes are up to 20 t3.2xlarge instances (8 vCPUs, 32 GiB), with autoscale
# (see https://github.com/huggingface/infra/pull/239/files)
# this means that we can get up to:
# 160 vCPUs and 640 GiB RAM are available (but no more than 8 cpus or 32 GiB for each pod)
#
# the max resources (limits) per deployment are:
# - reverse-proxy: 2 pods -> 2 CPUs, 512MiB
# - api: 4 pods -> 4 CPUs, 4 GiB
# - admin: 1 pod -> 1 CPU
# and for the workers:
# - datasets: 1 CPUs, 30 GiB
# - splits: 1 CPUs, 30 GiB
# We set the requested RAM to 8 GiB per worker, in order to trigger the autoscale. We should be able to
# launch 3 worker pods per node, taking the sidecars into account, it means 60 pods
#
# Being optimistic about not all the pods having to increase their memory usage to 30 GiB at the same time,
# ie over-committing a bit, we can set up to 60 workers (dataset + split).
#
# For now, we have to scale manually with:
#  kubectl scale --replicas=16 deploy/datasets-server-prod-worker-datasets
# or
#  kubectl scale --replicas=32 deploy/datasets-server-prod-worker-splits

mongodb:
  enabled: false
  # we use the secret instead to get the mongo URL

storage:
  nfs:
    path: "/fsx"
    server: "svm-0bd5fa426547fca22.fs-02050b8d555063cde.fsx.us-east-1.amazonaws.com"
    # https://us-east-1.console.aws.amazon.com/fsx/home?region=us-east-1#file-system-details/fs-02050b8d555063cde
    # Alarm: https://us-east-1.console.aws.amazon.com/cloudwatch/home?region=us-east-1#alarmsV2:alarm/Low+disk+on+datasets+server?

secrets:
  hfToken: hf-token
  mongoUrl: mongo-url

monitoring:
  enabled: true

adminDomain: "admin-datasets-server.us.dev.moon.huggingface.tech"
apiDomain: "datasets-server.huggingface.co"

ingress:
  annotations:
  # Link to Route53 - we could set any subdomain to us.dev.moon.huggingface.tech (common zone to the k8s cluster)
    external-dns.alpha.kubernetes.io/hostname: "admin-datasets-server.us.dev.moon.huggingface.tech"
    alb.ingress.kubernetes.io/certificate-arn: arn:aws:acm:us-east-1:707930574880:certificate/777e3ae5-0c54-47ee-9b8c-d85eeb6ec4ae
    alb.ingress.kubernetes.io/healthcheck-path: "/healthcheck"
    alb.ingress.kubernetes.io/listen-ports: '[{"HTTP": 80, "HTTPS": 443}]'
    alb.ingress.kubernetes.io/load-balancer-name: "hub-datasets-server-prod"
    alb.ingress.kubernetes.io/scheme: "internet-facing"
    alb.ingress.kubernetes.io/tags: "Env=prod,Project=datasets-server,Terraform=true"
    alb.ingress.kubernetes.io/target-node-labels: role-datasets-server=true
    kubernetes.io/ingress.class: "alb"

reverseProxy:
  replicas: 2

  service:
    annotations:
      service.beta.kubernetes.io/aws-load-balancer-additional-resource-tags: Env=prod,Project=datasets-server,Terraform=true
      service.beta.kubernetes.io/aws-load-balancer-name: hub-prod-datasets-server-nlb
      service.beta.kubernetes.io/aws-load-balancer-nlb-target-type: instance
      service.beta.kubernetes.io/aws-load-balancer-scheme: internal
      service.beta.kubernetes.io/aws-load-balancer-type: external
      service.beta.kubernetes.io/aws-load-balancer-target-node-labels: role-datasets-server=true

  nodeSelector:
    role-datasets-server: "true"

  tolerations:
    - key: CriticalAddonsOnly
      operator: Equal

  resources:
    requests:
      cpu: 1
      memory: "256Mi"
    limits:
      cpu: 1
      memory: "256Mi"

api:
  replicas: 4

  nodeSelector:
    role-datasets-server: "true"

  resources:
    requests:
      cpu: 1
      memory: "512Mi"
    limits:
      cpu: 1
      memory: "1Gi"

  appNumWorkers: "1"
  # Log level
  logLevel: "DEBUG"

worker:
  datasets:
    replicas: 4

    nodeSelector:
      role-datasets-server: "true"

    resources:
      requests:
        cpu: 1
        memory: "8Gi"
      limits:
        cpu: 1
        memory: "30Gi"

    # Log level
    logLevel: "DEBUG"

  splitsNext:
    replicas: 4

    nodeSelector:
      role-datasets-server: "true"

    resources:
      requests:
        cpu: 1
        memory: "8Gi"
      limits:
        cpu: 1
        memory: "30Gi"

    # Log level
    logLevel: "DEBUG"

  firstRows:
    replicas: 10

    nodeSelector:
      role-datasets-server: "true"

    resources:
      requests:
        cpu: 1
        memory: "8Gi"
      limits:
        cpu: 2
        memory: "30Gi"

    # Log level
    logLevel: "DEBUG"
    # Maximum number of jobs running at the same time for the same dataset
    maxJobsPerDataset: 3

  splits:
    replicas: 10

    nodeSelector:
      role-datasets-server: "true"

    resources:
      requests:
        cpu: 1
        memory: "8Gi"
      limits:
        cpu: 2
        memory: "30Gi"

    # Log level
    logLevel: "DEBUG"
    # Maximum number of jobs running at the same time for the same dataset
    maxJobsPerDataset: 3

admin:
  replicas: 1

  nodeSelector:
    role-datasets-server: "true"

  resources:
    requests:
      cpu: 1
    limits:
      cpu: 1

  appNumWorkers: "1"
  # Log level
  logLevel: "DEBUG"
